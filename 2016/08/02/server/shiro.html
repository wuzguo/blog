<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://wuzguo.com/blog/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://wuzguo.com/blog">
<meta name="author" content="Zàk (https://github.com/wuzguo)">

<link rel="stylesheet" href="/blog/css/SimpleStyle.css">


<!--代码高亮-->

<link rel="stylesheet" href="/blog/css/highlight/styles/default.css">

<!--使用Github风格的代码样式-->

<link rel="stylesheet" href="/blog/css/highlight/styles/github.css">


<link rel="shortcut icon" href="/blog/images/fav.ico">


<title>
    
    shiro学习笔记 -
    
    Zak&#39;s Home
    
</title>

<meta name="keywords" content="shiro">

<meta name="description " content="Apache Shiro权限管理框架的使用">
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/blog/" title="Zàk">Zàk</a>
        <a class="site-index current" href="/blog/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/blog/archives/" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/blog/tags/" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <a href="/blog/video/" title="视频"><i class="fa fa-video-camera"></i><span>视频</span></a>
        <a href="/blog/cross_fire/" title="链接"><i class="fa fa-wifi"></i><span>链接</span></a>
        <a href="/blog/help/" title="帮助"><i class="fa fa-question-circle"></i><span>帮助</span></a>
    </nav>
</div>
<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-weixin-mp" href="javascript:"><i class="fa fa-weixin"></i></a>
</div>
<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        <img class="avatar" width="72" src="/blog/images/avatar.png" alt="avatar" />
        <h1>Zàk</h1>
        <h4>日拱一卒，功不唐捐</h4>
        <p>一个追求进步的「十八线码农」</p>
        <div class="cover-sns">
            <div class="btn btn-homepage">
                <a href="http://wuzguo.com" target="_blank" rel="nofollow"><i class="fa fa-homepage"></i></a>
            </div>
            <div class="btn btn-github">
                <a href="https://github.com/wuzguo"  target="_blank" rel="nofollow"><i class="fa fa-github"></i></a>
            </div>
            <div class="btn btn-stack-overflow">
                <a href="https://stackoverflow.com/users/6716643/wuzguo" target="_blank" rel="nofollow"><i class="fa fa-stack-overflow"></i></a>
            </div>
            <div class="btn btn-facebook">
                <a href="https://www.facebook.com/wu.xsen"  target="_blank" rel="nofollow"><i class="fa fa-facebook"></i></a>
            </div>
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/blog/">最新</a></li>
        
            
                <li class="active">
                    <a href="/blog/categories/server/" data-name="后台">后台</a>
                </li>
            
                <li class="">
                    <a href="/blog/categories/front/" data-name="前端">前端</a>
                </li>
            
                <li class="">
                    <a href="/blog/categories/db/" data-name="数据库">数据库</a>
                </li>
            
                <li class="">
                    <a href="/blog/categories/os/" data-name="操作系统">操作系统</a>
                </li>
            
                <li class="">
                    <a href="/blog/categories/iot/" data-name="IoT">IoT</a>
                </li>
            
                <li class="">
                    <a href="/blog/categories/bigdata/" data-name="大数据">大数据</a>
                </li>
            
                <li class="">
                    <a href="/blog/categories/tools/" data-name="工具">工具</a>
                </li>
            
                <li class="">
                    <a href="/blog/categories/others/" data-name="其他">其他</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="请输入关键字" />
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/blog/',
        CONTENT_URL: '/blog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="http://www.wuzguo.com" target="_blank">
                    <img width="48" src="/blog/images/avatar.png" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="https://github.com/wuzguo" target="_blank">Zak</a>
                    <span title="最后编辑于2016-08-02">2016-08-02</span>
                </p>
                <p>一个追求进步的「十八线码农」</p>
            </div>
            <h2 class="post-title">Shiro学习笔记</h2>
            <div class="post-meta">
                本文总共23598个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <p>1.Shiro介绍<br>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能：</p>
<ul>
<li>认证 用户身份识别，常被称为用户“登录”</li>
<li>授权 访问控制</li>
<li>密码加密 保护或隐藏数据防止被偷窥</li>
<li>会话管理 每用户相关的时间敏感的状态</li>
</ul>
<p>对于任何一个应用程序，Shiro都可以提供全面的安全管理服务。并且相对于其他安全框架，Shiro要简单的多。</p>
<p>2.Shiro架构<br>首先，来了解一下Shiro的三个核心组件：Subject, SecurityManager 和 Realms. 如下图：<br><img src="/blog/images/201608/1.png"></p>
<p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。<br>Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。</p>
<p>SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。<br>SecurityManager默认实现结构：<br><img src="/blog/images/201608/5.png"></p>
<p>Realm：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色&#x2F;权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。<br>从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。</p>
<p>Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。</p>
<p>Shiro缺省Realm实现：<br><img src="/blog/images/201608/4.png"></p>
<p>实现自己的Realm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(UserRealm.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清楚授权的缓存，授权缓存以用户对象为键</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">clearCachedAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;[UserRealm] clearCachedAuthorizationInfo begin&quot;</span>);</span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="built_in">this</span>.getAuthorizationCache();</span><br><span class="line">        Set&lt;Object&gt; keys = cache.keys();</span><br><span class="line">        <span class="keyword">for</span> (Object object : keys) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;[UserRealm] clearCachedAuthorizationInfo object: &quot;</span> + object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.clearCachedAuthorizationInfo(principals);</span><br><span class="line">        logger.debug(<span class="string">&quot;[UserRealm] clearCachedAuthorizationInfo end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权，如果不使用缓存，每次访问新页面都会执行这个方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ((User) principals.getPrimaryPrincipal());</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> user.getCode();</span><br><span class="line">        System.out.println(user.getId() + <span class="string">&quot;,&quot;</span> + user.getNickname());</span><br><span class="line">        List&lt;Role&gt; roles = userService.listRoleByUserCode(code);</span><br><span class="line">        List&lt;AuthResource&gt; authResources = userService.listResByUserCode(code);</span><br><span class="line">        List&lt;String&gt; permissions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (AuthResource resource : authResources) &#123;</span><br><span class="line">            permissions.add(resource.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        <span class="comment">// info.setRoles(new HashSet&lt;String&gt;(roles));</span></span><br><span class="line">        info.setStringPermissions(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;(permissions));</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除认证的缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">clearCachedAuthenticationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;[UserRealm] clearCachedAuthenticationInfo begin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="built_in">this</span>.getAuthenticationCache();</span><br><span class="line">        Set&lt;Object&gt; keys = cache.keys();</span><br><span class="line">        <span class="keyword">for</span> (Object object : keys) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;[UserRealm] clearCachedAuthorizationInfo object: &quot;</span> + object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证的缓存以用户名为键，需要手动处理，否则退出登录时登录信息将不能被清除</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ((User) principals.getPrimaryPrincipal());</span><br><span class="line">        <span class="type">SimplePrincipalCollection</span> <span class="variable">simplePrincipalCollection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimplePrincipalCollection</span>(user.getUsername(), <span class="built_in">this</span>.getName());</span><br><span class="line">        <span class="built_in">super</span>.clearCachedAuthenticationInfo(simplePrincipalCollection);</span><br><span class="line">        logger.debug(<span class="string">&quot;[UserRealm] clearCachedAuthenticationInfo end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取认证信息，登录的时候调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> token.getPrincipal().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>((<span class="type">char</span>[]) token.getCredentials());</span><br><span class="line">        <span class="comment">// 获取用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.doGetUserInfo(username, password);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;[UserRealm] doGetAuthenticationInfo user is null&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;username invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SimpleAuthenticationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user, user.getSerct(), <span class="built_in">this</span>.getName());</span><br><span class="line">        <span class="comment">// 设置Salt值，增强密码破解的难度</span></span><br><span class="line">        info.setCredentialsSalt(ByteSource.Util.bytes(user.getUsername()));</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>Shiro完整架构图：</p>
<p><img src="/blog/images/201608/2.png"></p>
<p>3.Shiro认证与授权<br>认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息(Principals)和凭据信息(Credentials)以检验用户是否合法。最常见的“实体&#x2F;凭证”组合便是“用户名&#x2F;密码”组合。被 Shiro 保护的资源，才会经过认证与授权过程。使用 Shiro 对 URL 进行保护可以参见“与 Spring 集成”章节。用户访问受 Shiro 保护的 URL；例如 <a href="http://host/security/action.do%EF%BC%8CShiro">http://host/security/action.do，Shiro</a> 首先检查用户是否已经通过认证，如果未通过认证检查，则跳转到登录页面，否则进行授权检查。认证过程需要通过 Realm 来获取用户及密码信息，通常情况我们实现 JDBC Realm，此时用户认证所需要的信息从数据库获取。如果使用了缓存，除第一次外用户信息从缓存获取。认证通过后接受 Shiro 授权检查，授权检查同样需要通过 Realm 获取用户权限信息。Shiro 需要的用户权限信息包括 Role 或 Permission，可以是其中任何一种或同时两者，具体取决于受保护资源的配置。如果用户权限信息未包含 Shiro 需要的 Role 或 Permission，授权不通过。只有授权通过，才可以访问受保护 URL 对应的资源，否则跳转到“未经授权页面”。</p>
<p>3.1 身份认证流程<br>1.首先创建一个SecurityManager工厂<br>2.接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可；<br>3.通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后获取身份验证的Token，如用户名&#x2F;密码；<br>4.调用subject.login方法进行登录，其会自动委托给SecurityManager.login方法进行登录；<br>5.如果身份验证失败请捕获AuthenticationException或其子类，常见的如： DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等，具体请查看其继承关系；对于页面的错误消息展示，最好使用如“用户名&#x2F;密码错误”而不是“用户名错误”&#x2F;“密码错误”，防止一些恶意用户非法扫描帐号库；<br>6.最后可以调用subject.logout退出，其会自动委托给SecurityManager.logout方法退出。</p>
<p>从如上代码可总结出身份验证的步骤：<br>1.收集用户身份&#x2F;凭证，即如用户名&#x2F;密码；<br>2.调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；<br>3.最后调用Subject.logout进行退出操作。</p>
<p>流程图如下：<br><img src="/blog/images/201608/3.png"></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, Model model)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.2 Authenticator及AuthenticationStrategy<br>Authenticator的职责是验证用户帐号，是Shiro API中身份验证核心的入口点： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AuthenticationInfo <span class="title function_">authenticate</span><span class="params">(AuthenticationToken authenticationToken)</span>  <span class="keyword">throws</span> AuthenticationException;  </span><br></pre></td></tr></table></figure>
<p>如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败将抛出相应的AuthenticationException实现。</p>
<p>SecurityManager接口继承了Authenticator，另外还有一个ModularRealmAuthenticator实现，其委托给多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现：</p>
<p>FirstSuccessfulStrategy：只要有一个Realm验证成功即可，只返回第一个Realm身份验证成功的认证信息，其他的忽略；<br>AtLeastOneSuccessfulStrategy：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同，返回所有Realm身份验证成功的认证信息；<br>AllSuccessfulStrategy：所有Realm验证成功才算成功，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。</p>
<p>ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。</p>
<p>3.3 授权流程<br>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面&#x2F;编辑数据&#x2F;页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p>
<p>主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。<br>资源，在应用中用户可以访问的任何东西，比如访问JSP页面、查看&#x2F;编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。<br>权限，安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访问用户列表页面，查看&#x2F;新增&#x2F;修改&#x2F;删除用户数据（即很多时候都是CRUD（增查改删）式权限控制），打印文档等等…</p>
<p>如上可以看出，权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许，不反映谁去执行这个操作。所以后续还需要把权限赋予给用户，即定义哪个用户允许在某个资源上做什么操作（权限），Shiro不会去做这件事情，而是由实现人员提供。</p>
<p>角色，角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。<br>隐式角色：即直接通过角色来验证用户有没有操作权限，如在应用中CTO、技术总监、开发工程师可以使用打印机，假设某天不允许开发工程师使用打印机，此时需要从应用中删除相应代码；再如在应用中CTO、技术总监可以查看用户、查看权限；突然有一天不允许技术总监查看用户、查看权限了，需要在相关代码中把技术总监角色从判断逻辑中删除掉；即粒度是以角色为单位进行访问控制的，粒度较粗；如果进行修改可能造成多处代码修改。<br>显示角色：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可；无须修改多处代码；即粒度是以资源&#x2F;实例为单位的；粒度较细。</p>
<p>流程如下：<br>1.首先调用Subject.isPermitted*&#x2F;hasRole<em>接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；<br>2.Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；<br>3.在进行授权之前，其会调用相应的Realm获取Subject相应的角色&#x2F;权限用于匹配传入的角色&#x2F;权限；<br>4.Authorizer会判断Realm的角色&#x2F;权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted</em>&#x2F;hasRole*会返回true，否则返回false表示授权失败。</p>
<p>ModularRealmAuthorizer进行多Realm匹配流程：<br>1.首先检查相应的Realm是否实现了实现了Authorizer；<br>2.如果实现了Authorizer，那么接着调用其相应的isPermitted*&#x2F;hasRole*接口进行匹配；<br>3.如果有一个Realm匹配那么将返回true，否则返回false。</p>
<p>如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是：<br>1.如果调用hasRole*，则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可；<br>2.首先如果调用如isPermitted(“user:view”)，首先通过PermissionResolver将权限字符串转换成相应的Permission实例，默认使用WildcardPermissionResolver，即转换为通配符的WildcardPermission；<br>3.通过AuthorizationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo. getStringPermissions()得到字符串集合并通过PermissionResolver解析为Permission实例；然后获取用户的角色，并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）；<br>4.接着调用Permission. implies(Permission p)逐个与传入的权限比较，如果有匹配的则返回true，否则false。 </p>
<p>3.4 Authorizer、PermissionResolver及RolePermissionResolver<br>Authorizer的职责是进行授权（访问控制），是Shiro API中授权核心的入口点，其提供了相应的角色&#x2F;权限判断接口，具体请参考其Javadoc。SecurityManager继承了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例，而RolePermissionResolver用于根据角色解析相应的权限集合。</p>
<p>我们可以通过如下配置更改Authorizer实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">&lt;!--自定义permissionResolver--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;urlPermissionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.wzguo.service.shiro.resolver.WebUrlPermissionResolver&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;authorizer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.authz.ModularRealmAuthorizer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;permissionResolver&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;urlPermissionResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;authorizer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;authorizer&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>流程图如下：<br><img src="/blog/images/201608/6.png"></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="meta">@RequestMapping(params = &quot;myjsp&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">		<span class="keyword">if</span>(currentUser.isPermitted(<span class="string">&quot;user.do?myjsp&quot;</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;my&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;error/noperms&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@RequestMapping(params = &quot;notmyjsp&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">nopermission</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">		<span class="keyword">if</span>(currentUser.isPermitted(<span class="string">&quot;user.do?notmyjsp&quot;</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;notmyjsp&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;error/noperms&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.拦截器<br>4.1 拦截器介绍<br>Shiro使用了与Servlet一样的Filter接口进行扩展,首先下图是Shiro拦截器的基础类图：<br><img src="/blog/images/201608/7.png"></p>
<p>NameableFilter<br>NameableFilter给Filter起个名字，如果没有设置默认就是FilterName；还记得之前的如authc吗？当我们组装拦截器链时会根据这个名字找到相应的拦截器实例；</p>
<p>OncePerRequestFilter<br>OncePerRequestFilter用于防止多次执行Filter的；也就是说一次请求只会走一次拦截器链；另外提供enabled属性，表示是否开启该拦截器实例，默认enabled&#x3D;true表示开启，如果不想让某个拦截器工作，可以设置为false即可。</p>
<p>ShiroFilter<br>ShiroFilter是整个Shiro的入口点，用于拦截需要安全控制的请求进行处理，这个之前已经用过了。</p>
<p>AdviceFilter<br>AdviceFilter提供了AOP风格的支持，类似于SpringMVC中的Interceptor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(ServletRequest request, ServletResponse response, Exception exception)</span> <span class="keyword">throws</span> Exception;  </span><br></pre></td></tr></table></figure>
<p>preHandler：类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）<br>postHandle：类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；<br>afterCompletion：类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如接触Subject与线程的绑定之类的）；</p>
<p>PathMatchingFilter<br>PathMatchingFilter提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">pathsMatch</span><span class="params">(String path, ServletRequest request)</span>  </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>
<p>pathsMatch：该方法用于path与请求路径进行匹配的方法；如果匹配返回true；<br>onPreHandle：在preHandle中，当pathsMatch匹配一个路径后，会调用opPreHandler方法并将路径绑定参数配置传给mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回false中断流程；默认返回true；也就是说子类可以只实现onPreHandle即可，无须实现preHandle。如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。</p>
<p>AccessControlFilter<br>AccessControlFilter提供了访问控制的基础功能；比如是否允许访问&#x2F;当访问拒绝时如何处理等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception;  </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception;  </span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception;   </span><br></pre></td></tr></table></figure>
<p>isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false；<br>onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。</p>
<p>onPreHandle会自动调用这两个方法决定是否继续处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">return</span> isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>另外AccessControlFilter还提供了如下方法用于处理如登录成功后&#x2F;重定向到上一个请求： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setLoginUrl</span><span class="params">(String loginUrl)</span> <span class="comment">//身份验证时使用，默认/login.jsp  </span></span><br><span class="line">String <span class="title function_">getLoginUrl</span><span class="params">()</span>  </span><br><span class="line">Subject <span class="title function_">getSubject</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="comment">//获取Subject实例  </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isLoginRequest</span><span class="params">(ServletRequest request, ServletResponse response)</span><span class="comment">//当前请求是否是登录请求  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">saveRequestAndRedirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException <span class="comment">//将当前请求保存起来并重定向到登录页面  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">saveRequest</span><span class="params">(ServletRequest request)</span> <span class="comment">//将请求保存起来，如登录成功后再重定向回该请求  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">redirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="comment">//重定向到登录页面</span></span><br></pre></td></tr></table></figure>
<p>比如基于表单的身份验证就需要使用这些功能。</p>
<p>到此基本的拦截器就完事了，如果我们想进行访问访问的控制就可以继承AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承PathMatchingFilter。</p>
<p>4.2 拦截器链<br>Shiro对Servlet容器的FilterChain进行了代理，即ShiroFilter在继续Servlet容器的Filter链的执行之前，通过ProxiedFilterChain对Servlet容器的FilterChain进行了代理；即先走Shiro自己的Filter体系，然后才会委托给Servlet容器的FilterChain进行Servlet容器级别的Filter链执行；Shiro的ProxiedFilterChain执行流程：1、先执行Shiro自己的Filter链；2、再执行Servlet容器的Filter链（即原始的Filter）。<br>而ProxiedFilterChain是通过FilterChainResolver根据配置文件中[urls]部分是否与请求的URL是否匹配解析得到的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FilterChain <span class="title function_">getChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain originalChain)</span>;</span><br></pre></td></tr></table></figure>
<p>即传入原始的chain得到一个代理的chain。<br>Shiro内部提供了一个路径匹配的FilterChainResolver实现：PathMatchingFilterChainResolver，其根据[urls]中配置的url模式（默认Ant风格）&#x3D;拦截器链和请求的url是否匹配来解析得到配置的拦截器链的；而PathMatchingFilterChainResolver内部通过FilterChainManager维护着拦截器链，比如DefaultFilterChainManager实现维护着url模式与拦截器链的关系。因此我们可以通过FilterChainManager进行动态动态增加url模式与拦截器链的关系。</p>
<p>DefaultFilterChainManager会默认添加org.apache.shiro.web.filter.mgt.DefaultFilter中声明的拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DefaultFilter</span> &#123;  </span><br><span class="line">    anon(AnonymousFilter.class),  </span><br><span class="line">    authc(FormAuthenticationFilter.class),  </span><br><span class="line">    authcBasic(BasicHttpAuthenticationFilter.class),  </span><br><span class="line">    logout(LogoutFilter.class),  </span><br><span class="line">    noSessionCreation(NoSessionCreationFilter.class),  </span><br><span class="line">    perms(PermissionsAuthorizationFilter.class),  </span><br><span class="line">    port(PortFilter.class),  </span><br><span class="line">    rest(HttpMethodPermissionFilter.class),  </span><br><span class="line">    roles(RolesAuthorizationFilter.class),  </span><br><span class="line">    ssl(SslFilter.class),  </span><br><span class="line">    user(UserFilter.class);  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>如果要注册自定义拦截器，IniSecurityManagerFactory&#x2F;WebIniSecurityManagerFactory在启动时会自动扫描ini配置文件中的[filters]&#x2F;[main]部分并注册这些拦截器到DefaultFilterChainManager；且创建相应的url模式与其拦截器关系链。如果使用Spring后续章节会介绍如果注册自定义拦截器。</p>
<p>如果想自定义FilterChainResolver，可以通过实现WebEnvironment接口完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIniWebEnvironment</span> <span class="keyword">extends</span> <span class="title class_">IniWebEnvironment</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> FilterChainResolver <span class="title function_">createFilterChainResolver</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">//在此处扩展自己的FilterChainResolver  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.createFilterChainResolver();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterChain之间的关系。如果想动态实现url-拦截器的注册，就可以通过实现此处的FilterChainResolver来完成，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建FilterChainResolver  </span></span><br><span class="line"><span class="type">PathMatchingFilterChainResolver</span> <span class="variable">filterChainResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingFilterChainResolver</span>();  </span><br><span class="line"><span class="comment">//2、创建FilterChainManager  </span></span><br><span class="line"><span class="type">DefaultFilterChainManager</span> <span class="variable">filterChainManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFilterChainManager</span>();  </span><br><span class="line"><span class="comment">//3、注册Filter  </span></span><br><span class="line"><span class="keyword">for</span>(DefaultFilter filter : DefaultFilter.values()) &#123;  </span><br><span class="line">    filterChainManager.addFilter(  </span><br><span class="line">        filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass()));  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//4、注册URL-Filter的映射关系  </span></span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/login.jsp&quot;</span>, <span class="string">&quot;authc&quot;</span>);  </span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/unauthorized.jsp&quot;</span>, <span class="string">&quot;anon&quot;</span>);  </span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);  </span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;roles&quot;</span>, <span class="string">&quot;admin&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//5、设置Filter的属性  </span></span><br><span class="line"><span class="type">FormAuthenticationFilter</span> <span class="variable">authcFilter</span> <span class="operator">=</span>  </span><br><span class="line">         (FormAuthenticationFilter)filterChainManager.getFilter(<span class="string">&quot;authc&quot;</span>);  </span><br><span class="line">authcFilter.setLoginUrl(<span class="string">&quot;/login.jsp&quot;</span>);  </span><br><span class="line"><span class="type">RolesAuthorizationFilter</span> <span class="variable">rolesFilter</span> <span class="operator">=</span>  </span><br><span class="line">          (RolesAuthorizationFilter)filterChainManager.getFilter(<span class="string">&quot;roles&quot;</span>);  </span><br><span class="line">rolesFilter.setUnauthorizedUrl(<span class="string">&quot;/unauthorized.jsp&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">filterChainResolver.setFilterChainManager(filterChainManager);  </span><br><span class="line"><span class="keyword">return</span> filterChainResolver;   </span><br></pre></td></tr></table></figure>
<p>此处自己去实现注册filter，及url模式与filter之间的映射关系。可以通过定制FilterChainResolver或FilterChainManager来完成诸如动态URL匹配的实现。</p>
<p>然后再web.xml中进行如下配置Environment：  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroEnvironmentClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.github.zhangkaitao.shiro.chapter8.web.env.MyIniWebEnvironment<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span>   </span><br></pre></td></tr></table></figure>
<p>4.3 自定义拦截器<br>通过自定义自己的拦截器可以扩展一些功能，诸如动态url-角色&#x2F;权限访问控制的实现、根据Subject身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等等，因为其本质就是一个Filter；所以Filter能做的它就能做。</p>
<p>基于表单登录拦截器 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormLoginFilter</span> <span class="keyword">extends</span> <span class="title class_">PathMatchingFilter</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">loginUrl</span> <span class="operator">=</span> <span class="string">&quot;/login.jsp&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">successUrl</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span>(SecurityUtils.getSubject().isAuthenticated()) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//已经登录过  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;  </span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;  </span><br><span class="line">        <span class="keyword">if</span>(isLoginRequest(req)) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;post&quot;</span>.equalsIgnoreCase(req.getMethod())) &#123;<span class="comment">//form表单提交  </span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">loginSuccess</span> <span class="operator">=</span> login(req); <span class="comment">//登录  </span></span><br><span class="line">                <span class="keyword">if</span>(loginSuccess) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> redirectToSuccessUrl(req, resp);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//继续过滤器链  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//保存当前地址并重定向到登录界面  </span></span><br><span class="line">            saveRequestAndRedirectToLogin(req, resp);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">redirectToSuccessUrl</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        WebUtils.redirectToSavedRequest(req, resp, successUrl);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveRequestAndRedirectToLogin</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        WebUtils.saveRequest(req);  </span><br><span class="line">        WebUtils.issueRedirect(req, resp, loginUrl);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(HttpServletRequest req)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            SecurityUtils.getSubject().login(<span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            req.setAttribute(<span class="string">&quot;shiroLoginFailure&quot;</span>, e.getClass());  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLoginRequest</span><span class="params">(HttpServletRequest req)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>onPreHandle主要流程：<br>1、首先判断是否已经登录过了，如果已经登录过了继续拦截器链即可；<br>2、如果没有登录，看看是否是登录请求，如果是get方法的登录页面请求，则继续拦截器链（到请求页面），否则如果是get方法的其他页面请求则保存当前请求并重定向到登录页面；<br>3、如果是post方法的登录页面表单提交请求，则收集用户名&#x2F;密码登录即可，如果失败了保存错误消息到“shiroLoginFailure”并返回到登录页面；<br>4、如果登录成功了，且之前有保存的请求，则重定向到之前的这个请求，否则到默认的成功页面。</p>
<p>任意角色授权拦截器<br>Shiro提供roles拦截器，其验证用户拥有所有角色，没有提供验证用户拥有任意角色的拦截器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnyRolesFilter</span> <span class="keyword">extends</span> <span class="title class_">AccessControlFilter</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">unauthorizedUrl</span> <span class="operator">=</span> <span class="string">&quot;/unauthorized.jsp&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">loginUrl</span> <span class="operator">=</span> <span class="string">&quot;/login.jsp&quot;</span>;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        String[] roles = (String[])mappedValue;  </span><br><span class="line">        <span class="keyword">if</span>(roles == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果没有设置角色参数，默认成功  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(String role : roles) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(getSubject(request, response).hasRole(role)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//跳到onAccessDenied处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);  </span><br><span class="line">        <span class="keyword">if</span> (subject.getPrincipal() == <span class="literal">null</span>) &#123;<span class="comment">//表示没有登录，重定向到登录页面  </span></span><br><span class="line">            saveRequest(request);  </span><br><span class="line">            WebUtils.issueRedirect(request, response, loginUrl);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(unauthorizedUrl)) &#123;<span class="comment">//如果有未授权页面跳转过去  </span></span><br><span class="line">                WebUtils.issueRedirect(request, response, unauthorizedUrl);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则返回401未授权状态码  </span></span><br><span class="line">                WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>流程：<br>1、首先判断用户有没有任意角色，如果没有返回false，将到onAccessDenied进行处理；<br>2、如果用户没有角色，接着判断用户有没有登录，如果没有登录先重定向到登录；<br>3、如果用户没有角色且设置了未授权页面（unauthorizedUrl），那么重定向到未授权页面；否则直接返回401未授权错误码。</p>
<p>4.4 默认拦截器<br>Shiro内置了很多默认的拦截器，比如身份验证、授权等相关的。默认拦截器可以参考org.apache.shiro.web.filter.mgt.DefaultFilter中的枚举拦截器：</p>
<table><tr><th>拦截器名</th><th>拦截器类</th><th>使用场景</th><th>说明（括号里的表示默认值）</th></tr><tr><td>authc</td><td>FormAuthenticationFilter</td><td>验证</td><td>基于表单的拦截器,如"/****=authc",如果没有登录会跳到相应的登录页面登录:主要属性:usernameParam:表单提交的用户名参数名(username):passwordParam:表单提交的密码参数名(password):rememberMeParam:表单提交的密码参数名(rememberMe):loginUrl:登录页面地址(/login.jsp):successUrl:登录成功后的默认重定向地址:failureKeyAttribute:登录失败后错误信息存储key(shiroLoginFailure)</td></tr><tr><td>authcBasic</td><td>BasicHttpAuthenticationFilter</td><td>验证</td><td>Basic HTTP身份验证拦截器，主要属性： applicationName：弹出登录框显示的信息（application）Basic HTTP身份验证拦截器,主要属性:applicationName,弹出登录框显示的信息(application)</td></tr><tr><td>logout</td><td>LogoutFilter</td><td>验证</td><td>退出拦截器,主要属性:redirectUrl:退出成功后重定向的地址(/)示例"/logout=logout"</td></tr><tr><td>user</td><td>UserFilter</td><td>验证</td><td>用户拦截器,用户已经身份验证/记住我登录的都可:示例/****=user</td></tr><tr><td>anon</td><td>AnonymousFilter</td><td>验证</td><td>匿名拦截器，即不需要登录即可访问:一般用于静态资源过滤:示例"/static/****=anon"</td></tr><tr><td>roles</td><td>RolesAuthorizationFilter</td><td>授权</td><td>角色授权拦截器,验证用户是否拥有所有角色:主要属性:loginUrl:登录页面地址(/login.jsp):unauthorizedUrl:未授权后重定向的地址:示例"/admin/****=roles[admin]"</td></tr><tr><td>perms</td><td>PermissionsAuthorizationFilter</td><td>授权</td><td>权限授权拦截器,验证用户是否拥有所有权限:属性和roles一样:示例"/user/**=perms["user:create"]"</td></tr><tr><td>port</td><td>PortFilter</td><td>授权</td><td>端口拦截器,主要属性:port(80):可以通过的端口:示例"/test= port[80]",如果用户访问该页面是非80,将自动将请求端口改为80并重定向到该80端口,其他路径/参数等都一样</td></tr><tr><td>rest</td><td>HttpMethodPermissionFilter</td><td>授权</td><td>rest风格拦截器,自动根据请求方法构建权限字符串(GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create)构建权限字符串:示例"/users=rest[user]",会自动拼出"user:read,user:create,user:update,user:delete"权限字符串进行权限匹配(所有都得匹配,isPermittedAll)</td></tr><tr><td>ssl</td><td>SslFilter</td><td>授权</td><td>SSL拦截器,只有请求协议是https才能通过:否则自动跳转会https端口(443):其他和port拦截器一样SSL拦截器,只有请求协议是https才能通过:否则自动跳转会https端口(443):其他和port拦截器一样</td></tr><tr><td>noSessionCreation</td><td>NoSessionCreationFilter</td><td>其他</td><td>不创建会话拦截器,调用subject.getSession(false)不会有什么问题,但是如果subject.getSession(true)将抛出 DisabledSessionException异常</td></tr></table>
另外还提供了一个org.apache.shiro.web.filter.authz.HostFilter，即主机拦截器，比如其提供了属性：authorizedIps：已授权的ip地址，deniedIps：表示拒绝的ip地址；不过目前还没有完全实现，不可用。

<p>5.参考文章<br><a href="http://jinnianshilongnian.iteye.com/category/305053">跟我学Shiro</a></p>

        </div>
        <div class="post-tool">
            <a class="btn-weixin-mp" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-mobile" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/blog/tags/shiro/">shiro</a>
            
        </div>
        
    </article>
    
<div id="disqus_thread"></div>

<div class="clearfix" style="margin-top: 40px;">
</div>
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<!-- UY END -->

<!--PC版-->
<div id="SOHUCS" sid="12345678"></div>
<script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script>
<script type="text/javascript">
    window.changyan.api.config({
        appid: 'cyvlGm1zt',
        conf: 'prod_ed7bcebba567a04ee0d7b6bd13d280f8'
    });

    $(function () {
        function hash(text) {
            'use strict';
            var hash = 5381,
                index = text.length;
            while (index) {
                hash = (hash * 33) ^ text.charCodeAt(--index);
            }
            return hash >>> 0;
        }

        $('#SOHUCS').attr({
            "sid": hash(window.location.pathname)
        });
    });
</script>


<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    <!--添加友言评论系统，注释以下代码-->
    //  var disqus_config = function () {
    //      this.page.url = 'http://wuzguo.com/blog/2016/08/02/server/shiro.html';
    //      this.page.identifier = '2016/08/02/server/shiro.html';
    //  };
    //  (function () { // DON'T EDIT BELOW THIS LINE
    //      var d = document, disqus_shortname = 'wuzguo', s = d.createElement('script');
    //      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    //      s.setAttribute('data-timestamp', +new Date());
    //      (d.head || d.body).appendChild(s);
    //  })();
</script>

<!--添加友言评论系统，注释以下代码-->
<!--<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>-->

</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->


    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/blog/about/" title="关于本站">关于本站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/blog/help/" title="帮助">帮助</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/blog/video/" title="视频">视频</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/blog/links/" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/blog/app/" title="应用下载">应用下载</a>
        </p>
        <br/>
        <p>哪有什么天生如此，只要你天天坚持，自律给你自由</p>
        <br/>
        <p>
            © 2016-2021 本站点基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题作者<a href="https://www.tangkunyin.com" target="_blank">唐先森</a>，
            采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                 target="_blank">知识共享署名-非商业性使用-相同方式共享4.0国际许可协议</a>，已建站<a href="/timeline"
                                                                         id="siteBuildingTime"></a>天<br/>
        </p>
        
<p>
    <script type="text/javascript">
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1262530944'%3E%3C/span%3E%3Cscript src='//s4.cnzz.com/stat.php%3Fid%3D1262530944%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));
    </script>
</p>

    </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

<script src="/blog/css/highlight/highlight.pack.js"></script>
<script src="/blog/js/InsightSearch.js"></script>
<script src="/blog/js/SimpleCore.js"></script>


</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>

<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '04/24/2016',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            customImg: '/blog/images/weixin-mp.png'
        });

        <!--代码高亮-->
        $('.code pre').each(function (i, block) {
            hljs.highlightBlock(block);
        });
    });
</script>
<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/blog/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>